### 1. 圆圈上删数
圆圈上有0~n-1，共n个数字，从0开始，每次从中删除第m个数字，求最后剩下的一个数字

```python
# @param n int整型 数列大小
# @param m int整型 删除位数
# @return int整型
#
class Solution:
    def JosephCircle(self, n, m):
        circle = [i for i in range(n)]
        idx = 0

        while (len(circle) > 1):
            idx = (idx + m - 1) % len(circle)
            print(circle.pop(idx))

        return circle[0]
```


### 2. 合并两个有序数组
```python
# Get merged sorted list
# @param Input1 int整型一维数组 数组1
# @param Input2 int整型一维数组 数组2
# @return int整型一维数组
#
class Solution:
    def sorted_two_list(self , Input1, Input2):
        l1 = len(Input1)
        l2 = len(Input2)
        merged_list = []

        i, j = 0, 0
        while (i < l1) and (j < l2):
            if Input1[i] <= Input2[j]:
                merged_list.append(Input1[i])
                i += 1
            else:
                merged_list.append(Input2[j])
                j += 1
        
        if (i < l1):
            merged_list.extend(Input1[i:])
        
        if (j < l2):
            merged_list.extend(Input2[j:])

        return merged_list
```


### 3. LeetCode 4. 寻找两个正序数组的中位数
给定两个大小分别为m和n的正序（从小到大）数组nums1和nums2。请你找出并返回这两个正序数组的中位数。
算法的时间复杂度应该为 O(log (m+n)) 。
```python
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
            
```


### 4. 求一个数组的最大子数组之和
```python
class Solution:
    def maxArray(self, arr: list) -> int: 
        n = len(arr)

        def recursion(arr, left, right):
            if left == right:
                return arr[left]

            mid = (left + right) // 2
            leftSum = recursion(arr, left, mid)
            midSum = self.crossSum(arr, left, mid, right)
            rightSum = recursion(arr, mid+1, right)

            return max(leftSum, midSum, rightSum)
        
        return recursion(arr, 0, n-1)


    def crossSum(self, arr, left, mid, right):
        max_left_sum = float('-inf')
        max_right_sum = float('-inf')
        left_sum, right_sum = 0, 0

        for i in range(mid, left-1, -1):
            left_sum += arr[i]
            max_left_sum = max(left_sum, max_left_sum)

        for j in range(mid+1, right+1):
            right_sum += arr[j]
            max_right_sum = max(right_sum, max_right_sum)
        
        return max_left_sum + max_right_sum
```


### 5. 求1到999的素数：筛选法
```python
def prime():
    is_prime = [True] * 1000  # 更直观的命名
    is_prime[0] = is_prime[1] = False  # 0和1不是素数
    
    for i in range(2, int(1000**0.5) + 1):  # 只需检查到平方根
        if is_prime[i]:
            for j in range(i*i, 1000, i):  # 从i*i开始标记
                is_prime[j] = False
    
    for i in range(2, 1000):
        if is_prime[i]:
            print(i)

```